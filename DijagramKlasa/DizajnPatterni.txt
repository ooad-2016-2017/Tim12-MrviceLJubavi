Kreacijski patterni:

1. Adapter pattern
-Buduæi da klasa GlasanjeViewModel sadrži 3 interfejsa, od kojih se jedan bavi analizom glasaèkog sistema, a drugi objavljivanjem na Twitter,
ukoliko bi se kreirao još jedan glasaèki sistem (npr. odvojen za lokalne i opæe izbore) ili ukoliko bi se trebalo objavljivati na Twitter
i praviti analize bez obzira na èinjenicu što nisu u toku izbori, bilo bi neophodno mijenjati date klase i njihove implementacije tih
interfejsa, što nije dobro.
-Potrebno je kreirati Adapter klasu koja æe naslijediti interfejse Analiza i Twitter te ih implementirati na naèin koji odgovara
novim funkcionalnostima potrebnim u buduænosti. Na ovaj naèin klasni sistem æe biti otvoren za nadogradnju, a zatvoren za promjene.
2. Facade pattern
-Ovaj pattern pravi poveznicu izmeðu korisnièkih interfejsa (tj. formi), i logièkog pogleda sistema. Za implementaciju ovog metoda, potrebno je
napraviti klasu Facade koja bi objedinjavala sve logièke dijelove sistema. ViewModeli predstavljaju logièki dio sistema, te bi bilo potrebno napraviti
jednu klasu koja sadržavala ViewModele i koja bi navigirala njima zavisno od korisnièke interakcije sa sistemom.

3. Decorator pattern

4. Bridge pattern

5. Proxy pattern
-Klasa AdministratorViewModel, izmeðu ostalog, bavi se i provjerom da li osoba koja pokušava pristupiti posebnim opcijama ima ovlasti za takvo nešto.
Buduæi da je veoma važno zaštititi ovu klasu i njene moguænosti od neovlaštenog pristupa, potrebno je uvesti Proxy klasu koja æe onemoguæiti
pristup metodama i promjenu podataka ukoliko korisnik nema odgovarajuæe korisnièke podatke.
-Klasa AdministratorViewModel treba se deklarisati kao privatna, te je potrebno napraviti novu Proxy klasu koja æe izvršiti kreiranje instance
klase AdministratorViewModel. Kada korisnik unese korisnièke podatke, pozvati æe se metoda Authenticate koja æe instancirati klasu samo ukoliko
su uneseni ispravni korisnièki podaci.
6. Composite pattern

7. Flyweight pattern
-Uloga flyweight patterna je da smanji potrošnju memorije time što æe "reciklirati" objekte koji se interno ne razlikuju jedan od drugog.
No, kako su u našim klasama svi atributi jedne instance, razlièiti od atributa druge instance, te se ne mogu uspostaviti interne, zajednièke karakteristike,
tako ovaj pattern nije primjenjiv za naš sistem. 

Kreacijski patterni:

1. Singleton pattern
-U klasnom modelu postoji nekoliko klasa koje ne bi trebalo biti moguæe instancirati više puta - AdministratorViewModel, GlasanjeViewModel i
OstaleFunkcionalnostiViewModel. Ukoliko bi bilo više instanci ovih klasa, bilo bi više naèina da se unese glas, obrišu podaci korisnika ili prikažu
najvažnije informacije, što bi bilo neprihvatljivo. Zbog toga je potrebno onemoguæiti da se kreira više objekata ovih klasa.
-Potrebno je kreirati klasu Singleton koja æe instancirati željenu klasu. Ta klasa æe posjedovati metodu koja æe uvijek vraæati istu instancu.
2. Prototype pattern

3. Factory Method pattern
-Ovaj pattern koristi posebne metode za instanciranje objekata umjesto konstruktora, kada nam je potrebno da ne navodimo koja tacno klasa ce biti instancirana.
U našem sistemu postoji samo jedna abstraktna klasa (Osoba), koja je generalizacija klasa Kandidat i Glasaè. Kako nam je u svakom trenutku poznato koji tip instance
nam treba, tj. ne treba nam metoda da utvrdimo šta trebamo kreirati, tako ovaj pattern nije primjenjiv na naš sistem.

4. Abstract Factory pattern
-Slièno kao prethodni patern, i ovaj patern koristi metode za instanciranje objekata, umjesto konstruktora, samo što ovaj pattern ima jednu "SuperFactory" koja
kontroliše instanciranje svih tipova objekta u sistemu. Kako je nama u svakom trenutku poznato koji tip instance nam treba, tj. ne treba nam metoda da utvrdimo 
šta trebamo kreirati, tako ovaj pattern nije primjenjiv na naš sistem.

5. Builder pattern
-Buduæi da se u klasnom modelu ne implementira "gradnja" od više dijelova, te nema ni više klasa koje bi na razlièite naèine "gradile" objekte,
Builder pattern se ne može primijeniti. U klasnom modelu nema prosljeðivanja objekata klasa kao parametara više puta izmeðu više klasa s jednim konaènim
rezultatom, te automatski nema ni moguænosti da se primijeni ovaj pattern.
